# Data Flow - Notes

## Overview

The chrislyons-website has **two distinct data flow patterns**:

1. **Static SPA Flow**: Client-side routing and content loading (no server requests)
2. **Dynamic Worker Flow**: Server-side rendering and database operations

Understanding which flow applies to which route is critical for debugging and feature development.

## Flow 1: SPA Page Load (Static Content)

### Routes Affected
- `/` (home)
- `/apps` and `/apps/*`
- `/ideas` and `/ideas/*`
- `/sounds` and `/sounds/*`
- `/connect`

### Flow Description

1. **User Action**: Click link or enter URL
2. **Link Interception**: Router intercepts link clicks with `href^="/"`
3. **Route Matching**: Router checks routes map for matching handler
4. **Handler Invocation**: Router calls registered route handler (e.g., `renderAppsPage()`)
5. **Content Loading**: Handler uses ContentLoader to get page data from `content/` directory
6. **Component Rendering**: Handler instantiates components (Card, PageHeader, etc.)
7. **DOM Update**: Handler injects HTML into `#page-content` div
8. **Event Binding**: Handler calls `attachEventListeners()` on components
9. **History Update**: Router calls `history.pushState()` to update URL
10. **Scroll**: Router scrolls to top of page

### Data Sources
- `content/*.md` - Markdown files with page content
- `content.json` - Site-wide metadata
- `src/data/songs.js` - Generated song lyrics

### Key Characteristics
- **No server request** (except initial page load)
- **Instant navigation** (no network latency)
- **Client-side rendering** (JavaScript generates HTML)
- **SEO limitations** (content not in initial HTML)

### State Changes
- `router.currentRoute` updated
- `window.history` updated
- `document.title` updated
- DOM updated with new content

### Performance
- **Time to Interactive**: <100ms (local operations only)
- **Network**: 0 requests
- **JavaScript Execution**: Minimal (render + attach)

## Flow 2: Blog Page Load (Dynamic Content)

### Routes Affected
- `/blog`
- `/admin`
- `/rss.xml`
- `/images/*`

### Flow Description

1. **User Action**: Navigate to /blog
2. **No Interception**: Router allows full page navigation (doesn't intercept)
3. **HTTP Request**: Browser makes GET request to server
4. **Development Mode**:
   - Vite proxy receives request on port 5173
   - Proxy forwards to Worker on localhost:8787
5. **Production Mode**:
   - Request goes directly to Cloudflare Worker
6. **Route Handler**: Worker routes to `GET /blog` handler
7. **Database Query**: Worker queries D1 for published entries
8. **Template Rendering**: Worker generates HTML with blog entries
9. **HTTP Response**: Worker returns HTML to browser
10. **Browser Rendering**: Browser displays server-rendered HTML

### Data Sources
- Cloudflare D1 database (`entries` table)
- Worker templates (HTML generation)

### Key Characteristics
- **Full page load** (not SPA)
- **Server-side rendering** (HTML generated by Worker)
- **Database-backed** (dynamic content)
- **SEO-friendly** (content in initial HTML)

### State Changes
- **None on client** (new page load)
- Browser history updated (normal navigation)

### Performance
- **Time to First Byte**: 50-200ms (edge computing)
- **Database Query**: 10-50ms
- **Template Rendering**: 5-20ms

## Flow 3: Admin Authentication

### Routes Affected
- `/admin` (all methods)
- `/admin/*` (all protected routes)

### Flow Description

**First Visit (Unauthenticated)**:
1. User navigates to /admin
2. Worker receives GET /admin
3. Worker calls `isAuthenticated(c)`
4. Worker checks for session cookie
5. Cookie not found ‚Üí Not authenticated
6. Worker renders login page HTML
7. Browser displays login form

**Login Submission**:
1. User enters credentials and submits form
2. Browser POSTs to /admin/login with FormData
3. Worker extracts username and password
4. Worker compares with hardcoded credentials
5. **If valid**:
   - Worker sets HTTP-only session cookie
   - Cookie value: `SESSION_TOKEN` ("authenticated")
   - Cookie expires in 7 days
   - Worker redirects to /admin (302)
   - Browser follows redirect to /admin
6. **If invalid**:
   - Worker renders login page with error message
   - Browser displays error

**Authenticated Visit**:
1. User navigates to /admin (with valid cookie)
2. Worker receives GET /admin
3. Worker calls `isAuthenticated(c)`
4. Worker finds and validates session cookie
5. Worker queries D1 for all entries
6. Worker renders admin dashboard HTML
7. Browser displays admin interface

### Security Considerations

**Current Implementation**:
- Hardcoded credentials in source code (SECURITY ISSUE)
- Simple token-based session (not cryptographically secure)
- HTTP-only cookies (good - prevents XSS)
- Secure flag (good - HTTPS only)
- SameSite=Lax (good - CSRF protection)

**Technical Debt**:
- Move credentials to environment variables or Cloudflare Secrets
- Consider using bcrypt or similar for password hashing
- Add rate limiting for login attempts
- Add session invalidation on logout
- Add CSRF tokens for state-changing operations

### Cookie Details
- **Name**: `admin_session`
- **Value**: `authenticated` (static token)
- **HttpOnly**: true (not accessible via JavaScript)
- **Secure**: true (HTTPS only)
- **SameSite**: Lax (protects against CSRF)
- **Max-Age**: 604800 seconds (7 days)
- **Path**: `/` (entire site)

## Flow 4: Create Blog Entry

### Flow Description (Authenticated User)

1. User in admin dashboard clicks "Create Entry"
2. Admin.js triggers `createEntry('text')` function
3. Function collects form data (type, content, published)
4. Function POSTs JSON to /admin/entry
5. Worker receives POST /admin/entry
6. Worker calls `isAuthenticated(c)` middleware
7. Worker validates session cookie
8. **If authenticated**:
   - Worker parses JSON body
   - Worker extracts type, content, published, metadata
   - Worker prepares INSERT statement
   - Worker calculates next position_index (MAX + 1)
   - Worker executes: `INSERT INTO entries (...) VALUES (...)`
   - D1 returns entry ID
   - Worker queries: `SELECT * FROM entries WHERE id = ?`
   - D1 returns new entry object
   - Worker responds with JSON: `{id, type, content, created_at, ...}`
   - Admin.js receives response
   - Admin.js updates UI with new entry
   - Admin.js shows success message
9. **If not authenticated**:
   - Worker responds with 401 Unauthorized
   - Admin.js displays error
   - Admin.js may redirect to login

### Request Format
```json
POST /admin/entry
Content-Type: application/json

{
  "type": "text",
  "content": {
    "text": "My blog entry",
    "font": "Inter",
    "fontSize": "16px"
  },
  "published": true,
  "metadata": {
    "font": "Inter"
  }
}
```

### Response Format
```json
{
  "id": 123,
  "type": "text",
  "content": "{\"text\":\"My blog entry\",\"font\":\"Inter\"}",
  "created_at": "2025-11-08T12:00:00Z",
  "updated_at": "2025-11-08T12:00:00Z",
  "published": 1,
  "position_index": 5,
  "metadata": "{\"font\":\"Inter\"}"
}
```

### Data Transformations
- **Client ‚Üí Server**: JavaScript object ‚Üí JSON string
- **Server ‚Üí Database**: JSON string ‚Üí SQL parameter
- **Database ‚Üí Server**: SQL row ‚Üí JavaScript object
- **Server ‚Üí Client**: JavaScript object ‚Üí JSON response

### State Changes
- D1 database updated (new row in entries table)
- Client DOM updated (new entry in list)
- No localStorage changes
- No cookie changes

## Flow 5: Theme Toggle

### Flow Description

**Via Click**:
1. User clicks theme toggle button
2. Browser triggers click event
3. Event handler calls `ThemeToggle.toggle()`

**Via Keyboard**:
1. User presses `\` key
2. Global keyboard handler (in main.js) detects key
3. Handler calls `themeToggle.toggle()`
4. Handler re-renders theme toggle buttons

**Both Paths Continue**:
1. `toggle()` calls `getNextTheme()`
2. `getNextTheme()` calculates next theme in cycle:
   - Moonlight ‚Üí Daylight ‚Üí Forest ‚Üí Beach ‚Üí Moonlight
3. `toggle()` calls `setTheme(newTheme)`
4. `setTheme()` calls `applyTheme(newTheme)`
5. `applyTheme()` removes all theme classes from `<html>`
6. `applyTheme()` adds new theme class (e.g., `theme-forest`)
7. `applyTheme()` saves to localStorage: `theme = 'forest'`
8. CSS variables update based on theme class
9. All themed elements re-render with new colors

### Theme Cycle
```
Moonlight (dark blue)
    ‚Üì
Daylight (light white)
    ‚Üì
Forest (dark green)
    ‚Üì
Beach (warm gold-yellow-blue)
    ‚Üì
(back to Moonlight)
```

### Theme Icons
- **Moonlight**: üåô Moon
- **Daylight**: ‚òÄÔ∏è Sun
- **Forest**: üçÉ Leaf
- **Beach**: ü™Å Kite

### localStorage Key
- **Key**: `theme`
- **Value**: One of: `moonlight`, `daylight`, `forest`, `beach`
- **Default**: `moonlight` (if not set)

### CSS Classes Applied
```html
<!-- Before -->
<html class="theme-moonlight">

<!-- After toggle -->
<html class="theme-daylight">
```

### State Changes
- `themeToggle.theme` updated
- `localStorage.theme` updated
- `document.documentElement.className` updated
- Theme toggle button icon updated

### Performance
- **Execution Time**: <10ms
- **Repaints**: Full page (CSS variables change)
- **Network**: 0 requests
- **Persistence**: localStorage write

## Flow 6: Upload Image (R2)

**Note**: R2 integration is currently disabled in wrangler.toml. This flow describes the intended implementation.

### Flow Description

1. User in admin dashboard selects image file
2. Admin.js triggers `uploadImage(file)` function
3. Function creates FormData with file
4. Function POSTs FormData to /admin/upload
5. Worker receives POST /admin/upload
6. Worker calls `isAuthenticated(c)`
7. Worker extracts file from FormData
8. Worker validates file exists
9. Worker generates filename:
   - Timestamp: `Date.now()`
   - Sanitized original filename
   - Format: `{timestamp}-{sanitized_filename}`
10. Worker uploads to R2:
    - Bucket: BLOG_IMAGES
    - Key: filename
    - Body: file.stream()
    - Metadata: contentType from file
11. R2 stores file
12. Worker responds with JSON: `{url: '/images/filename'}`
13. Admin.js receives response
14. Admin.js inserts image URL into entry editor
15. Admin.js shows preview of uploaded image

### Request Format
```
POST /admin/upload
Content-Type: multipart/form-data

file: [binary data]
```

### Response Format
```json
{
  "url": "/images/1699459200000-my_image.jpg"
}
```

### Image Retrieval Flow

1. Browser requests `/images/1699459200000-my_image.jpg`
2. Worker receives GET /images/:filename
3. Worker extracts filename from URL parameter
4. Worker queries R2 bucket: `bucket.get(filename)`
5. R2 returns object with body and metadata
6. Worker creates Response:
   - Body: object.body (stream)
   - Content-Type: object.httpMetadata.contentType
   - Cache-Control: public, max-age=31536000, immutable
7. Browser receives image
8. Browser caches image for 1 year

### Data Transformations
- **Browser ‚Üí Worker**: File object ‚Üí FormData
- **Worker ‚Üí R2**: File stream ‚Üí Stored object
- **R2 ‚Üí Worker**: Stored object ‚Üí Response stream
- **Worker ‚Üí Browser**: Response stream ‚Üí Image display

### Security Considerations
- **Authentication required** for upload
- **Filename sanitization** (removes special characters)
- **No file type validation** (potential security issue)
- **No file size limits** (potential abuse)
- **Public read access** (/images/* not authenticated)

### Technical Debt
- Add file type validation (allow only images)
- Add file size limits
- Add virus scanning (if needed)
- Add image optimization (resize, compress)
- Consider signed URLs for private images

## Flow 7: Song Lyrics Display

### Flow Description

1. User navigates to /sounds/lyrics
2. Router intercepts link click
3. Router calls `renderLyricsPage()`
4. Handler imports `songs` from `src/data/songs.js`
5. Handler instantiates `new SongAccordion(songs)`
6. SongAccordion.render() generates HTML:
   - Loop through songs array
   - Create card for each song with title
   - Lyrics hidden by default (CSS)
   - Add data-song-id attribute
7. Handler injects HTML into #page-content
8. Handler calls attachEventListeners()
9. SongAccordion attaches click handlers to all song titles
10. Browser displays song list (all collapsed)

**User Interaction**:
1. User clicks song title
2. Click handler calls `SongAccordion.toggle(songId)`
3. toggle() checks if song is currently open
4. **If song is closed**:
   - Close currently open song (if any)
   - Open clicked song
   - Update `openSongId` state
   - Toggle CSS classes (add 'expanded')
   - Lyrics slide down (CSS transition)
5. **If song is open**:
   - Close song
   - Clear `openSongId` state
   - Remove 'expanded' class
   - Lyrics slide up (CSS transition)

### Data Source

**Build-Time Generation**:
1. Developer edits `src/data/songs/*.md`
2. Developer runs `node scripts/parse-song-lyrics.js`
3. Script reads all .md files in songs/ directory
4. Script parses markdown format
5. Script converts verses to HTML (paragraphs with line breaks)
6. Script generates `src/data/songs.js`
7. Developer commits both markdown and generated file

**Markdown Format**:
```markdown
# Song Title

C. Lyons

Verse one line one
Verse one line two

Verse two line one
Verse two line two
```

**Generated Format**:
```javascript
export const songs = [
  {
    title: 'Song Title',
    lyrics: `
      <p>Verse one line one<br/>
      Verse one line two</p>

      <p>Verse two line one<br/>
      Verse two line two</p>
    `
  }
];
```

### State Management
- **Component State**: `openSongId` (which song is expanded)
- **DOM State**: CSS classes on song cards
- **No Persistence**: State resets on navigation

### Performance
- **Initial Load**: ~50ms (render all songs)
- **Toggle**: <5ms (CSS class change)
- **Animation**: ~300ms (CSS transition)

## Flow 8: RSS Feed Generation

### Flow Description

1. User navigates to /rss.xml (or RSS reader fetches)
2. Browser makes GET request to /rss.xml
3. Worker routes to RSS handler
4. Worker queries D1:
   - `SELECT * FROM entries WHERE published = 1 ORDER BY created_at DESC LIMIT 50`
5. D1 returns up to 50 most recent published entries
6. Worker generates RSS XML:
   - Loops through entries
   - Parses JSON content field
   - Formats entry based on type (text, image, gif, quote)
   - Creates `<item>` element for each entry
7. Worker sets Content-Type: `application/rss+xml; charset=utf-8`
8. Worker responds with XML string
9. Browser or RSS reader parses XML
10. RSS reader displays entries

### RSS Format

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Infinite Canvas Blog</title>
    <link>https://chrislyons.boot.industries/blog</link>
    <description>Visual thoughts in an endless scroll</description>
    <language>en-us</language>
    <lastBuildDate>Fri, 08 Nov 2025 12:00:00 GMT</lastBuildDate>

    <item>
      <title>Text Entry</title>
      <link>https://chrislyons.boot.industries/blog/entry/123</link>
      <guid>https://chrislyons.boot.industries/blog/entry/123</guid>
      <pubDate>Fri, 08 Nov 2025 10:00:00 GMT</pubDate>
      <description><![CDATA[Entry content here]]></description>
    </item>
  </channel>
</rss>
```

### Entry Type Formatting

**Text Entry**:
```xml
<description><![CDATA[The text content]]></description>
```

**Image Entry**:
```xml
<description><![CDATA[
  <img src="/images/photo.jpg" alt="Alt text" />
  <p>Caption here</p>
]]></description>
```

**GIF Entry**:
```xml
<description><![CDATA[
  <img src="https://giphy.com/gif.gif" alt="GIF" />
]]></description>
```

**Quote Entry**:
```xml
<description><![CDATA[
  <blockquote>"Quote text" ‚Äî Author</blockquote>
]]></description>
```

### Performance
- **Query Time**: 10-50ms (50 entries)
- **XML Generation**: 5-20ms
- **Total Time**: 15-70ms

## Flow 9: Canvas Creator

### Flow Description

**Load Editor**:
1. User navigates to /admin/create
2. Worker checks authentication
3. Worker renders canvas creator HTML
4. Browser loads canvas-creator.js
5. Canvas-creator.js initializes editor:
   - Empty canvas (default: 1080x1920 Stories format)
   - White background
   - Empty elements array
6. Browser displays interactive canvas editor

**Add Element**:
1. User clicks "Add Text" (or Image/GIF/Sticker)
2. canvas-creator.js creates new element object:
   ```javascript
   {
     id: 'el-' + uuid(),
     type: 'text',
     content: { text: 'New text', font: 'Inter', fontSize: 20, color: '#000' },
     position: { x: 100, y: 100 },
     size: { width: 200, height: 'auto' },
     rotation: 0,
     zIndex: elements.length
   }
   ```
3. Add element to canvas state
4. Render element on canvas
5. Make element draggable/resizable

**Edit Element**:
1. User drags, resizes, or rotates element
2. canvas-creator.js updates element properties
3. Re-render element with new properties
4. Update internal canvas state

**Save Canvas**:
1. User clicks "Save Canvas"
2. canvas-creator.js serializes canvas state
3. POST JSON to /admin/canvas:
   ```json
   {
     "title": "My Canvas",
     "background": {"type": "solid", "value": "#ffffff"},
     "dimensions": {"width": 1080, "height": 1920},
     "elements": [ /* array of elements */ ],
     "published": true
   }
   ```
4. Worker validates authentication
5. Worker inserts into D1:
   - JSON.stringify() for background, dimensions, elements
   - Calculate position_index (MAX + 1)
6. D1 returns new canvas ID
7. Worker queries for full canvas object
8. Worker responds with JSON
9. canvas-creator.js shows success message
10. Browser may redirect to canvas view

### Canvas Data Model

**Background Types**:
```javascript
{ type: 'solid', value: '#ffffff' }
{ type: 'gradient', value: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)' }
{ type: 'image', value: '/images/bg-123.jpg' }
```

**Dimension Presets**:
```javascript
{ width: 1080, height: 1920 }  // Stories (9:16 portrait)
{ width: 1080, height: 1080 }  // Square (1:1)
{ width: 1440, height: 810 }   // Desktop (16:9)
```

**Element Structure**:
```javascript
{
  id: 'el-abc123',
  type: 'text' | 'image' | 'gif' | 'sticker',
  content: {
    text?: string,
    font?: string,
    fontSize?: number,
    color?: string,
    url?: string,
    emoji?: string
  },
  position: { x: number, y: number },
  size: { width: number, height: number | 'auto' },
  rotation: number,  // degrees
  zIndex: number
}
```

### State Management
- **Canvas State**: Background, dimensions, elements array
- **Selected Element**: Currently active element (for editing)
- **Persistence**: Save to D1 on demand (not auto-save)

## Data Transformation Summary

### Content Markdown ‚Üí HTML
- **Input**: Markdown files in `content/`
- **Transformer**: contentLoader.js (runtime)
- **Output**: HTML injected into DOM

### Song Lyrics Markdown ‚Üí JavaScript
- **Input**: Markdown files in `src/data/songs/*.md`
- **Transformer**: scripts/parse-song-lyrics.js (build-time)
- **Output**: JavaScript module `src/data/songs.js`

### Vite Build ‚Üí Asset Manifest
- **Input**: Source files in `src/`
- **Transformer**: Vite build + scripts/generate-asset-manifest.js
- **Output**: `dist/` directory + asset-manifest.json

### Blog Entries Database ‚Üí HTML
- **Input**: D1 entries table (JSON content field)
- **Transformer**: Worker template rendering
- **Output**: Server-rendered HTML

### Blog Entries Database ‚Üí RSS XML
- **Input**: D1 entries table
- **Transformer**: Worker RSS generator
- **Output**: XML feed

## State Management Patterns

### Client-Side State
- **Router State**: Current route (transient)
- **Theme State**: Current theme (persistent in localStorage)
- **Component State**: Component-specific state (transient)
- **Navigation State**: Mobile menu open/closed (transient)
- **Accordion State**: Which song/section is open (transient)

### Server-Side State
- **Session State**: Admin authentication (persistent in HTTP-only cookie)
- **Database State**: Blog entries, canvases (persistent in D1)
- **Asset State**: Uploaded images (persistent in R2)

### No Global State Management
The application deliberately avoids global state management libraries (Redux, MobX, etc.) because:
- Simple content-focused application
- Each page re-renders from scratch
- State is ephemeral and route-specific
- Reduces complexity and bundle size

## Performance Characteristics

### SPA Routes (Static Content)
- **Time to Interactive**: <100ms
- **Network Requests**: 0 (after initial load)
- **JavaScript Execution**: Minimal (render + attach)
- **SEO**: Limited (content not in initial HTML)

### Worker Routes (Dynamic Content)
- **Time to First Byte**: 50-200ms (edge computing)
- **Database Query**: 10-50ms
- **Template Rendering**: 5-20ms
- **SEO**: Excellent (server-rendered HTML)

### Hybrid Benefits
- Fast navigation for static content
- Dynamic features where needed
- Edge computing for low latency
- Minimal JavaScript for static pages

## Related Diagrams

- [repo-structure.mermaid.md](repo-structure.mermaid.md) - Directory layout
- [architecture-overview.mermaid.md](architecture-overview.mermaid.md) - System design
- [component-map.mermaid.md](component-map.mermaid.md) - Component relationships
- [entry-points.mermaid.md](entry-points.mermaid.md) - Application initialization
- [database-schema.mermaid.md](database-schema.mermaid.md) - Database structure
- [deployment-infrastructure.mermaid.md](deployment-infrastructure.mermaid.md) - Deployment architecture
